                                               -----------------------
                                                 Reactive Tutorial 
                                               -----------------------
					                            Daniel Sagenschneider
                                               -----------------------

  <<Reactive Tutorial>>

  This tutorial demonstrates using Reactive logic within WoOF.

  It will use the {{{/apidocs/net/officefloor/spring/webclient/WebClientManagedObjectSource.html}WebClientManagedObjectSource}} to make an asynchronous call to another REST end point.
  
  To avoid having to start multiple servers, the call will be back onto a REST end point of the same server.  As such, the configuration for this tutorial is the following:

[./images/ReactiveHttpServer-configuration.png] ReactiveHttpServer screen shot.
   
  {{{http://sourceforge.net/projects/officefloor/files/maven/maven2/net/officefloor/tutorial/ReactiveHttpServer/${projectVersion}/ReactiveHttpServer-${projectVersion}-project.zip/download}Download Tutorial Source}}



Server

  Before getting to the Reactive logic, the Server logic that is called asynchronously is the following:
  
%{snippet|id=tutorial|file=${basedir}/src/main/java/net/officefloor/tutorial/reactivehttpserver/ServerLogic.java|ignoreDownloadError=false}

  With the following response object:
  
%{snippet|id=tutorial|file=${basedir}/src/main/java/net/officefloor/tutorial/reactivehttpserver/ServerResponse.java|ignoreDownloadError=false}

  This is very simple, however, will show how the Reactive logic can call this end point asynchronously.



Reactive logic

  The following is the reactive logic to call the above server:
  
%{snippet|id=tutorial|file=${basedir}/src/main/java/net/officefloor/tutorial/reactivehttpserver/ReactiveLogic.java|ignoreDownloadError=false}

  You can see the reactive logic making a call to the above server.
  
  To indicate when the Reactive logic is complete, the injected {{{/apidocs/net/officefloor/frame/api/function/AsynchronousFlow.html}AsynchronousFlow}} has a completion method.  This completion method must be called by the Reactive logic within a reasonable amount of time.  Otherwise, OfficeFloor will timeout the asynchronous logic.  This is because OfficeFloor ensures all flows progress by timing out any asynchronous flows taking too long.

  Also, if there is more than one Reactive stream, more than one {{{/apidocs/net/officefloor/frame/api/function/AsynchronousFlow.html}AsynchronousFlow}} may be injected.  However, note that all {{{/apidocs/net/officefloor/frame/api/function/AsynchronousFlow.html}AsynchronousFlow}} instances must be completed before the flow continues.

  To make integration between Reactive and {{{/apidocs/net/officefloor/frame/api/function/AsynchronousFlow.html}AsynchronousFlow}} easier, the {{{/apidocs/net/officefloor/spring/reactive/ReactiveWoof.html}ReactiveWoof}} provides common subscription consumers.



Note on thread safety  
  
  It is expected that the Reactive subscribe handler will be called in a different thread than the one invoking the Reactive stream.  In other words, the web call will be triggered by the OfficeFloor provided thread, but the callback once the response is returned is done on the Netty event loop thread.  Therefore, to ensure thread safety by OfficeFloor, updates of injected objects should be done within the {{{/apidocs/net/officefloor/frame/api/function/AsynchronousFlow.html}AsynchronousFlow}} completion method.



Testing

  The following shows invoking the reactive code that asynchronously pulls data from the server:
  
%{snippet|id=tutorial|file=${basedir}/src/test/java/net/officefloor/tutorial/reactivehttpserver/ReactiveHttpServerTest.java|ignoreDownloadError=false}



Next

  The {{{../KotlinHttpServer/index.html}next tutorial}} covers Kotlin.
