options{    LOOKAHEAD= 1;    CHOICE_AMBIGUITY_CHECK = 2;    OTHER_AMBIGUITY_CHECK = 1;    STATIC = false;    DEBUG_PARSER = false;    DEBUG_LOOKAHEAD = false;    DEBUG_TOKEN_MANAGER = false;    ERROR_REPORTING = true;    JAVA_UNICODE_ESCAPE = false;    UNICODE_INPUT = false;    IGNORE_CASE = true;    USER_TOKEN_MANAGER = false;    USER_CHAR_STREAM = false;    BUILD_PARSER = true;    BUILD_TOKEN_MANAGER = true;    SANITY_CHECK = true;    FORCE_LA_CHECK = false;}PARSER_BEGIN(WebTemplateParser)package net.officefloor.web.template.parse;import java.util.List;import java.util.LinkedList;import java.io.IOException;import java.io.Reader;/**
 * Web template parser.
 *
 * @author Daniel Sagenschneider
 * @author javacc (many thanks to this wonderful tool)
 */public class WebTemplateParser{    /**     * Default name for the first {@link ParsedTemplateSection}.     */    public static final String DEFAULT_FIRST_SECTION_NAME = "template";    /**     * Listing of {@link ParsedTemplateSection} instances.      */    private List < ParsedTemplateSection > sections = new LinkedList < ParsedTemplateSection > ();    /**	 * Current {@link ParsedTemplateSection} name.	 */    private String currentSectionName = null;    /**	 * {@link NodeParsedTemplateSectionContent} for the {@link ParsedTemplateSection}.	 */    private NodeParsedTemplateSectionContent currentSectionContents = new NodeParsedTemplateSectionContent("SECTION_BEAN", null);    /**	 * {@link NodeParsedTemplateSectionContent} for the current bean.	 */    private NodeParsedTemplateSectionContent currentBeanContents = this.currentSectionContents;    /**     * Current static HTML content.     */    private StringBuilder currentStaticContent = new StringBuilder();    /**	 * Current raw section content.	 */    private StringBuilder currentRawSectionContent = new StringBuilder();    /**     * Parses the input.     *     * @param content Template content.     */    public static ParsedTemplate parse(Reader templateContent) throws IOException    {        // Create the parser        WebTemplateParser parser = new WebTemplateParser(templateContent);        try        {            // Parse the template            parser.parseTemplate();            // Complete the last section            parser.completeCurrentSection();        }        catch (ParseException ex)        {            // Failed to parse template            throw new IOException(ex);        }        // Return the template        return new ParsedTemplate(parser.sections.toArray(new ParsedTemplateSection [parser.sections.size()]));    }    /**	 * Adds a {@link ParsedTemplateSection}.	 */    private void addSection(String sectionName)    {        // Complete the current section        this.completeCurrentSection();        // Parse out the comment, white spacing, brackets        sectionName = sectionName.substring("<!--".length(), (sectionName.length() - "-->".length()));        sectionName = sectionName.trim();        sectionName = sectionName.substring("{".length(), (sectionName.length() - "}".length()));        // Specify the new section name        this.currentSectionName = sectionName;    }    /**	 * Adds a {@link BeanParsedTemplateSectionContent} that is within a comment.	 */    public void addCommentBean(String beanName)    {        // Add the raw content        this.currentRawSectionContent.append(beanName);        // Parse out comment and white spacing        beanName = beanName.substring("<!--".length(), (beanName.length() - "-->".length()));        beanName = beanName.trim();        // Add the bean        this.addBean(beanName, true);    }    /**	 * Adds a {@link BeanParsedTemplateSectionContent}.	 */    private void addBean(String beanName, boolean isWithinComment)    {        // Add the raw content (if not within comment)        if (!isWithinComment)        {            this.currentRawSectionContent.append(beanName);        }        // Complete static content        this.completeStaticContent();        // Parse out bean bracket, white spacing        beanName = beanName.substring("${".length());        beanName = beanName.trim();        // Create the node content for the bean        NodeParsedTemplateSectionContent beanContent = new NodeParsedTemplateSectionContent(beanName, this.currentBeanContents);        // Add content and set as current bean        this.currentBeanContents.addContent(beanContent);        this.currentBeanContents = beanContent;    }    /**	 * Completes the current {@link BeanParsedTemplateSectionContent}.	 */    private void completeBean(Token token) throws ParseException    {        // Add the raw content        this.currentRawSectionContent.append(token);        // Complete static content        this.completeStaticContent();        // Move to parent bean        this.currentBeanContents = this.currentBeanContents.getParent();        // Ensure have parent        if (this.currentBeanContents == null)        {            throw new ParseException("No open Bean to close at line " + token.beginLine + " column " + token.beginColumn);        }    }    /**	 * Adds a {@link PropertyParsedTemplateSectionContent}.	 */    private void addProperty(String propertyName)    {        // Add the raw content        this.currentRawSectionContent.append(propertyName);        // Complete static content        this.completeStaticContent();        // Parse out property brackets        propertyName = propertyName.substring("${".length(), (propertyName.length() - "}".length()));        // Add the property        this.currentBeanContents.addContent(new NodeParsedTemplateSectionContent(new PropertyParsedTemplateSectionContent(propertyName)));    }    /**	 * Adds a {@link LinkParsedTemplateSectionContent}.	 */    private void addLink(String linkName)    {        // Add the raw content        this.currentRawSectionContent.append(linkName);        // Complete static content        this.completeStaticContent();        // Parse out link brackets        linkName = linkName.substring("#{".length(), (linkName.length() - "}".length()));        // Add the link        this.currentBeanContents.addContent(new NodeParsedTemplateSectionContent(new LinkParsedTemplateSectionContent(linkName)));    }    /**	 * Adds the static content for a {@link StaticParsedTemplateSectionContent}.	 */    private void addStaticContent(String staticContent)    {        // Add the raw content        this.currentRawSectionContent.append(staticContent);        // Add the static content        this.currentStaticContent.append(staticContent);    }    /**	 * Completes current {@link StaticParsedTemplateSectionContent}.	 */    private void completeStaticContent()    {        // Must have static content        String content = this.currentStaticContent.toString();        if (content.length() == 0)        {            return; // no static content        }        // Append the static content        this.currentBeanContents.addContent(new NodeParsedTemplateSectionContent(new StaticParsedTemplateSectionContent(content)));        // Clear for next static content        this.currentStaticContent = new StringBuilder();    }    /**	 * Completes current {@link ParsedTemplateSection}. 	 */    private void completeCurrentSection()    {        // Ensure content complete        this.completeStaticContent();        // Must have content for section        if (!this.currentSectionContents.isContent())        {            return; // no contents, so do not include section        }        // Obtain the current section name        String sectionName = (this.currentSectionName == null ? DEFAULT_FIRST_SECTION_NAME : this.currentSectionName);        // Obtain the contents and reset for next section        BeanParsedTemplateSectionContent sectionBean = (BeanParsedTemplateSectionContent) this.currentSectionContents.getParsedTemplateSectionContent();        ParsedTemplateSectionContent [] sectionContents = sectionBean.getContent();        this.currentSectionContents = new NodeParsedTemplateSectionContent("SECTION_BEAN", null);        this.currentBeanContents = this.currentSectionContents;        // Create and add the section        ParsedTemplateSection section = new ParsedTemplateSection(sectionName, this.currentRawSectionContent.toString(), sectionContents);        this.sections.add(section);        // Reset for next section raw content        this.currentRawSectionContent = new StringBuilder();    }    /**	 * {@link ParsedTemplateSectionContent} node within the parsing of the {@link ParsedTemplateSection}.	 */    private static class NodeParsedTemplateSectionContent implements ParsedTemplateSectionContent    {        /**         * Property name to obtain the bean.         */        private final String beanName;        /**		 * {@link ParsedTemplateSectionContent} instances for the bean.		 */        private final List < NodeParsedTemplateSectionContent > contents;        /**		 * Parent {@link NodeParsedTemplateSectionContent}.		 */        private final NodeParsedTemplateSectionContent parent;        /**		 * Delegate {@link ParsedTemplateSectionContent}.		 */        private final ParsedTemplateSectionContent delegate;        /**		 * Initiate to be {@link BeanParsedTemplateSectionContent}.		 */        public NodeParsedTemplateSectionContent(String beanName, NodeParsedTemplateSectionContent parent)        {            this.beanName = beanName;            this.contents = new LinkedList < NodeParsedTemplateSectionContent > ();            this.parent = parent;            this.delegate = null;        }        /**		 * Initiate with delegate {@link ParsedTemplateSectionContent}.		 */        public NodeParsedTemplateSectionContent(ParsedTemplateSectionContent delegate)        {            this.beanName = null;            this.contents = null;            this.parent = null;            this.delegate = delegate;        }        /**		 * Adds a {@link NodeParsedTemplateSectionContent}.		 */        public void addContent(NodeParsedTemplateSectionContent content)        {            this.contents.add(content);        }        /**		 * Indicates if contains a {@link NodeParsedTemplateSectionContent}.		 */        public boolean isContent()        {            return (this.contents.size() > 0);        }        /**		 * Obtains the parent {@link NodeParsedTemplateSectionContent}.		 */        public NodeParsedTemplateSectionContent getParent()        {            return this.parent;        }        /**		 * Obtains the {@link ParsedTemplateSectionContent}.		 */        public ParsedTemplateSectionContent getParsedTemplateSectionContent()        {            // Determine if delegate content            if (this.delegate != null)            {                return this.delegate;            }            // As here it is a bean so generate the bean            ParsedTemplateSectionContent [] beanContents = new ParsedTemplateSectionContent [this.contents.size()];            for (int i = 0; i < beanContents.length; i++)            {                beanContents [i] = this.contents.get(i).getParsedTemplateSectionContent();            }            // Create and return the Bean content            BeanParsedTemplateSectionContent beanContent = new BeanParsedTemplateSectionContent(this.beanName, beanContents);            return beanContent;        }    }}PARSER_END(WebTemplateParser)TOKEN :{    < LINK : "#{" (( < NAME > )+ ("," < NAME >)* ":")? < NAME > "}" >|   < PROPERTY : "${" < REFERENCE > "}" >|   < SECTION : "<!--" (< WHITE_SPACE >)* "{" < SECTION_NAME > "}" (< WHITE_SPACE >)* "-->" >|   < BEAN_COMMENT_OPEN : "<!--" (< WHITE_SPACE >)* < BEAN_OPEN > (< WHITE_SPACE >)* "-->" >|   < BEAN_COMMENT_CLOSE : "<!--" (< WHITE_SPACE >)* < BEAN_CLOSE > (< WHITE_SPACE >)* "-->" >|   < BEAN_OPEN : "${" < REFERENCE > (< WHITE_SPACE >)? >|   < BEAN_CLOSE : (< WHITE_SPACE >)? "$}" >|   < STATIC : ~[ ] >|   < #WHITE_SPACE : [ " ", "\t", "\n", "\r" ] >|   < #REFERENCE : < NAME > ("." < NAME >)* >|   < #SECTION_NAME :          ( (":")? < NAME > )        | "!" >|   < #NAME : [ "A"-"Z", "a"-"z" ] ([ "A"-"Z", "a"-"z", "0"-"9", "_" ])* >}/** * Parses the template. */void parseTemplate() :{}{    (        LOOKAHEAD(< SECTION >)        parseSection()    |   LOOKAHEAD(< BEAN_COMMENT_OPEN >)        parseBeanCommentOpen()    |   LOOKAHEAD(< BEAN_COMMENT_CLOSE >)        parseBeanCommentClose()    |   LOOKAHEAD(< BEAN_OPEN >)        parseBeanOpen()    |   LOOKAHEAD(< BEAN_CLOSE >)        parseBeanClose()    |   LOOKAHEAD(< PROPERTY >)        parseProperty()    |   LOOKAHEAD(< LINK >)        parseLink()    |   LOOKAHEAD(< STATIC >)        parseStaticContent()    )*    < EOF >}/** * Parses the section. */void parseSection() :{    Token t;}{    t = < SECTION >    {        this.addSection(t.image);    }}/** * Parses the bean open. */void parseBeanOpen() :{    Token t;}{    t = < BEAN_OPEN >    {        this.addBean(t.image, false);    }}/** * Parses the bean open. */void parseBeanCommentOpen() :{    Token t;}{    t = < BEAN_COMMENT_OPEN >    {        this.addCommentBean(t.image);    }}/** * Parses the bean close. */void parseBeanClose() :{    Token t;}{    t = < BEAN_CLOSE >    {        this.completeBean(t);    }}/** * Parses the bean close. */void parseBeanCommentClose() :{    Token t;}{    t = < BEAN_COMMENT_CLOSE >    {        this.completeBean(t);    }}/** * Parses the property. */void parseProperty() :{    Token t;}{    t = < PROPERTY >    {        this.addProperty(t.image);    }}/** * Parses the link. */void parseLink() :{    Token t;}{    t = < LINK >    {        this.addLink(t.image);    }}/** * Parses the static content. */void parseStaticContent() :{    Token t;}{    t = < STATIC >    {        this.addStaticContent(t.image);    }}